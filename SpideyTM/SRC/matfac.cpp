#include "global.h"
////////////////////////////////////////////////////////////////////////////////////////////////////
/*
mat_fac

  a platform independent facade to the material class that lets you load ngl materials from text file
  chunks ArchEngine style
*/
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "global.h"

#include "aggvertbuf.h"
#include "material.h"
#include "osdevopts.h"

#include "game.h"
#include "wds.h" // unfortunately.... sigh

#include "matfac.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
static char g_debug_material_fname[32]="spankygod";

static char g_debug_texture_fname[32]="blank";

////////////////////////////////////////////////////////////////////////////////////////////////////

mat_fac::mat_fac()
{
	PANIC;
}


mat_fac::mat_fac(const mat_fac& b)
{
#ifndef NGL
  m_pcmat = NULL;
#endif

  *this = b;
}

mat_fac::~mat_fac()
{
	PANIC;
}

mat_fac& mat_fac::operator=(const mat_fac& b)
{
	PANIC;
}

void mat_fac::load_material(const stringx &file)
{
	PANIC;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void serial_in( chunk_file& io, mat_fac* m, const stringx& texture_dir, unsigned additional_flags )
{
	PANIC;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
int mat_fac::get_anim_length() const

{
#ifdef NGL
  return 1;
#else
  return m_pcmat ? m_pcmat->get_anim_length() : 1;
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////
bool mat_fac::is_translucent() const
{
	PANIC;
	return true;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
void mat_fac::send_context( int frame,
                            map_e map,
                            unsigned force_flags,
                            color32 force_color )
{
#ifdef NGL
#else

  if(m_pcmat)
    m_pcmat->send_context( frame, map, force_flags, force_color );
  else

    g_game_ptr->get_blank_material()->send_context( frame, map, force_flags, force_color );
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////
bool mat_fac::has_texture( void ) const
{
	PANIC;
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
int mat_fac::get_original_width( int frame, map_e map ) const
{
	PANIC;
	return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
int mat_fac::get_original_height( int frame, map_e map ) const
{
	PANIC;
	return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
unsigned mat_fac::get_blend_mode( int m ) const
{
	PANIC;
	return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
void mat_fac::set_blend_mode( unsigned _mode, int m )
{
	PANIC;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// non NGL only functiosn
#ifndef NGL
extern world_dynamics_system * g_world_ptr;
////////////////////////////////////////////////////////////////////////////////////////////////////
aggregate_vert_buf* mat_fac::find_mat_buf( int last_frame, unsigned force_flags )
{
  aggregate_vert_buf* matbuf = g_world_ptr->get_matvertbufs().find( m_pcmat, last_frame, force_flags );
  return matbuf;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
hw_texture* mat_fac::get_texture( int frame, map_e map ) const
{
  return m_pcmat->get_texture( frame, map ); 
}
#endif
